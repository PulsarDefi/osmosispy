"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _PerpetualMarketType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _PerpetualMarketTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_PerpetualMarketType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PERPETUAL_MARKET_TYPE_UNSPECIFIED: _PerpetualMarketType.ValueType  # 0
    """Unspecified market type."""
    PERPETUAL_MARKET_TYPE_CROSS: _PerpetualMarketType.ValueType  # 1
    """Market type for cross margin perpetual markets."""
    PERPETUAL_MARKET_TYPE_ISOLATED: _PerpetualMarketType.ValueType  # 2
    """Market type for isolated margin perpetual markets."""

class PerpetualMarketType(_PerpetualMarketType, metaclass=_PerpetualMarketTypeEnumTypeWrapper): ...

PERPETUAL_MARKET_TYPE_UNSPECIFIED: PerpetualMarketType.ValueType  # 0
"""Unspecified market type."""
PERPETUAL_MARKET_TYPE_CROSS: PerpetualMarketType.ValueType  # 1
"""Market type for cross margin perpetual markets."""
PERPETUAL_MARKET_TYPE_ISOLATED: PerpetualMarketType.ValueType  # 2
"""Market type for isolated margin perpetual markets."""
global___PerpetualMarketType = PerpetualMarketType

@typing.final
class Perpetual(google.protobuf.message.Message):
    """Perpetual represents a perpetual on the dYdX exchange."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARAMS_FIELD_NUMBER: builtins.int
    FUNDING_INDEX_FIELD_NUMBER: builtins.int
    OPEN_INTEREST_FIELD_NUMBER: builtins.int
    funding_index: builtins.bytes
    """The current index determined by the cumulative all-time
    history of the funding mechanism. Starts at zero.
    """
    open_interest: builtins.bytes
    """Total size of open long contracts, measured in base_quantums."""
    @property
    def params(self) -> global___PerpetualParams:
        """PerpetualParams is the parameters of the perpetual."""

    def __init__(
        self,
        *,
        params: global___PerpetualParams | None = ...,
        funding_index: builtins.bytes = ...,
        open_interest: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["params", b"params"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["funding_index", b"funding_index", "open_interest", b"open_interest", "params", b"params"]) -> None: ...

global___Perpetual = Perpetual

@typing.final
class PerpetualParams(google.protobuf.message.Message):
    """PerpetualParams represents the parameters of a perpetual on the dYdX
    exchange.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    TICKER_FIELD_NUMBER: builtins.int
    MARKET_ID_FIELD_NUMBER: builtins.int
    ATOMIC_RESOLUTION_FIELD_NUMBER: builtins.int
    DEFAULT_FUNDING_PPM_FIELD_NUMBER: builtins.int
    LIQUIDITY_TIER_FIELD_NUMBER: builtins.int
    MARKET_TYPE_FIELD_NUMBER: builtins.int
    id: builtins.int
    """Unique, sequentially-generated."""
    ticker: builtins.str
    """The name of the `Perpetual` (e.g. `BTC-USD`)."""
    market_id: builtins.int
    """The market associated with this `Perpetual`. It
    acts as the oracle price for the purposes of calculating
    collateral, margin requirements, and funding rates.
    """
    atomic_resolution: builtins.int
    """The exponent for converting an atomic amount (`size = 1`)
    to a full coin. For example, if `AtomicResolution = -8`
    then a `PerpetualPosition` with `size = 1e8` is equivalent to
    a position size of one full coin.
    """
    default_funding_ppm: builtins.int
    """The default funding payment if there is no price premium. In
    parts-per-million.
    """
    liquidity_tier: builtins.int
    """The liquidity_tier that this perpetual is associated with."""
    market_type: global___PerpetualMarketType.ValueType
    """The market type specifying if this perpetual is cross or isolated"""
    def __init__(
        self,
        *,
        id: builtins.int = ...,
        ticker: builtins.str = ...,
        market_id: builtins.int = ...,
        atomic_resolution: builtins.int = ...,
        default_funding_ppm: builtins.int = ...,
        liquidity_tier: builtins.int = ...,
        market_type: global___PerpetualMarketType.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["atomic_resolution", b"atomic_resolution", "default_funding_ppm", b"default_funding_ppm", "id", b"id", "liquidity_tier", b"liquidity_tier", "market_id", b"market_id", "market_type", b"market_type", "ticker", b"ticker"]) -> None: ...

global___PerpetualParams = PerpetualParams

@typing.final
class MarketPremiums(google.protobuf.message.Message):
    """MarketPremiums stores a list of premiums for a single perpetual market."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PERPETUAL_ID_FIELD_NUMBER: builtins.int
    PREMIUMS_FIELD_NUMBER: builtins.int
    perpetual_id: builtins.int
    """perpetual_id is the Id of the perpetual market."""
    @property
    def premiums(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """premiums is a list of premium values for a perpetual market. Since most
        premiums are zeros under "stable" market conditions, only non-zero values
        are stored in this list.
        """

    def __init__(
        self,
        *,
        perpetual_id: builtins.int = ...,
        premiums: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["perpetual_id", b"perpetual_id", "premiums", b"premiums"]) -> None: ...

global___MarketPremiums = MarketPremiums

@typing.final
class PremiumStore(google.protobuf.message.Message):
    """PremiumStore is a struct to store a perpetual premiums for all
    perpetual markets. It stores a list of `MarketPremiums`, each of which
    corresponds to a perpetual market and stores a list of non-zero premium
    values for that market.
    This struct can either be used to store `PremiumVotes` or
    `PremiumSamples`.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ALL_MARKET_PREMIUMS_FIELD_NUMBER: builtins.int
    NUM_PREMIUMS_FIELD_NUMBER: builtins.int
    num_premiums: builtins.int
    """number of rounds where premium values were added. This value indicates
    the total number of premiums (zeros and non-zeros) for each
    `MarketPremiums` struct. Note that in the edge case a perpetual market was
    added in the middle of a epoch, we don't keep a seperate count for that
    market. This means we treat this market as having zero premiums before it
    was added.
    """
    @property
    def all_market_premiums(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MarketPremiums]:
        """all_market_premiums a list of `MarketPremiums`, each corresponding to
        a perpetual market.
        """

    def __init__(
        self,
        *,
        all_market_premiums: collections.abc.Iterable[global___MarketPremiums] | None = ...,
        num_premiums: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["all_market_premiums", b"all_market_premiums", "num_premiums", b"num_premiums"]) -> None: ...

global___PremiumStore = PremiumStore

@typing.final
class LiquidityTier(google.protobuf.message.Message):
    """LiquidityTier stores margin information."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    INITIAL_MARGIN_PPM_FIELD_NUMBER: builtins.int
    MAINTENANCE_FRACTION_PPM_FIELD_NUMBER: builtins.int
    BASE_POSITION_NOTIONAL_FIELD_NUMBER: builtins.int
    IMPACT_NOTIONAL_FIELD_NUMBER: builtins.int
    OPEN_INTEREST_LOWER_CAP_FIELD_NUMBER: builtins.int
    OPEN_INTEREST_UPPER_CAP_FIELD_NUMBER: builtins.int
    id: builtins.int
    """Unique id."""
    name: builtins.str
    """The name of the tier purely for mnemonic purposes, e.g. "Gold"."""
    initial_margin_ppm: builtins.int
    """The margin fraction needed to open a position.
    In parts-per-million.
    """
    maintenance_fraction_ppm: builtins.int
    """The fraction of the initial-margin that the maintenance-margin is,
    e.g. 50%. In parts-per-million.
    """
    base_position_notional: builtins.int
    """The maximum position size at which the margin requirements are
    not increased over the default values. Above this position size,
    the margin requirements increase at a rate of sqrt(size).

    Deprecated since v3.x.
    """
    impact_notional: builtins.int
    """The impact notional amount (in quote quantums) is used to determine impact
    bid/ask prices and its recommended value is 500 USDC / initial margin
    fraction.
    - Impact bid price = average execution price for a market sell of the
    impact notional value.
    - Impact ask price = average execution price for a market buy of the
    impact notional value.
    """
    open_interest_lower_cap: builtins.int
    """Lower cap for Open Interest Margin Fracton (OIMF), in quote quantums.
    IMF is not affected when OI <= open_interest_lower_cap.
    """
    open_interest_upper_cap: builtins.int
    """Upper cap for Open Interest Margin Fracton (OIMF), in quote quantums.
    IMF scales linearly to 100% as OI approaches open_interest_upper_cap.
    If zero, then the IMF does not scale with OI.
    """
    def __init__(
        self,
        *,
        id: builtins.int = ...,
        name: builtins.str = ...,
        initial_margin_ppm: builtins.int = ...,
        maintenance_fraction_ppm: builtins.int = ...,
        base_position_notional: builtins.int = ...,
        impact_notional: builtins.int = ...,
        open_interest_lower_cap: builtins.int = ...,
        open_interest_upper_cap: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["base_position_notional", b"base_position_notional", "id", b"id", "impact_notional", b"impact_notional", "initial_margin_ppm", b"initial_margin_ppm", "maintenance_fraction_ppm", b"maintenance_fraction_ppm", "name", b"name", "open_interest_lower_cap", b"open_interest_lower_cap", "open_interest_upper_cap", b"open_interest_upper_cap"]) -> None: ...

global___LiquidityTier = LiquidityTier
