"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import dydxprotocol.indexer.protocol.v1.subaccount_pb2
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _ClobPairStatus:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ClobPairStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ClobPairStatus.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    CLOB_PAIR_STATUS_UNSPECIFIED: _ClobPairStatus.ValueType  # 0
    """Default value. This value is invalid and unused."""
    CLOB_PAIR_STATUS_ACTIVE: _ClobPairStatus.ValueType  # 1
    """CLOB_PAIR_STATUS_ACTIVE behavior is unfinalized.
    TODO(DEC-600): update this documentation.
    """
    CLOB_PAIR_STATUS_PAUSED: _ClobPairStatus.ValueType  # 2
    """CLOB_PAIR_STATUS_PAUSED behavior is unfinalized.
    TODO(DEC-600): update this documentation.
    """
    CLOB_PAIR_STATUS_CANCEL_ONLY: _ClobPairStatus.ValueType  # 3
    """CLOB_PAIR_STATUS_CANCEL_ONLY behavior is unfinalized.
    TODO(DEC-600): update this documentation.
    """
    CLOB_PAIR_STATUS_POST_ONLY: _ClobPairStatus.ValueType  # 4
    """CLOB_PAIR_STATUS_POST_ONLY behavior is unfinalized.
    TODO(DEC-600): update this documentation.
    """
    CLOB_PAIR_STATUS_INITIALIZING: _ClobPairStatus.ValueType  # 5
    """CLOB_PAIR_STATUS_INITIALIZING represents a newly-added clob pair.
    Clob pairs in this state only accept orders which are
    both short-term and post-only.
    """
    CLOB_PAIR_STATUS_FINAL_SETTLEMENT: _ClobPairStatus.ValueType  # 6
    """CLOB_PAIR_STATUS_FINAL_SETTLEMENT represents a clob pair that has been
    deactivated. Clob pairs in this state do not accept new orders and trading
    is blocked. All open positions are closed and open stateful orders canceled
    by the protocol when the clob pair transitions to this status. All
    short-term orders are left to expire.
    """

class ClobPairStatus(_ClobPairStatus, metaclass=_ClobPairStatusEnumTypeWrapper):
    """Status of the CLOB.
    Defined in clob.clob_pair
    """

CLOB_PAIR_STATUS_UNSPECIFIED: ClobPairStatus.ValueType  # 0
"""Default value. This value is invalid and unused."""
CLOB_PAIR_STATUS_ACTIVE: ClobPairStatus.ValueType  # 1
"""CLOB_PAIR_STATUS_ACTIVE behavior is unfinalized.
TODO(DEC-600): update this documentation.
"""
CLOB_PAIR_STATUS_PAUSED: ClobPairStatus.ValueType  # 2
"""CLOB_PAIR_STATUS_PAUSED behavior is unfinalized.
TODO(DEC-600): update this documentation.
"""
CLOB_PAIR_STATUS_CANCEL_ONLY: ClobPairStatus.ValueType  # 3
"""CLOB_PAIR_STATUS_CANCEL_ONLY behavior is unfinalized.
TODO(DEC-600): update this documentation.
"""
CLOB_PAIR_STATUS_POST_ONLY: ClobPairStatus.ValueType  # 4
"""CLOB_PAIR_STATUS_POST_ONLY behavior is unfinalized.
TODO(DEC-600): update this documentation.
"""
CLOB_PAIR_STATUS_INITIALIZING: ClobPairStatus.ValueType  # 5
"""CLOB_PAIR_STATUS_INITIALIZING represents a newly-added clob pair.
Clob pairs in this state only accept orders which are
both short-term and post-only.
"""
CLOB_PAIR_STATUS_FINAL_SETTLEMENT: ClobPairStatus.ValueType  # 6
"""CLOB_PAIR_STATUS_FINAL_SETTLEMENT represents a clob pair that has been
deactivated. Clob pairs in this state do not accept new orders and trading
is blocked. All open positions are closed and open stateful orders canceled
by the protocol when the clob pair transitions to this status. All
short-term orders are left to expire.
"""
global___ClobPairStatus = ClobPairStatus

@typing.final
class IndexerOrderId(google.protobuf.message.Message):
    """Initial copy of protos from dYdX chain application state protos for the clob
    module for use to send Indexer specific messages. Do not make any breaking
    changes to these protos, a new version should be created if a breaking change
    is needed.

    IndexerOrderId refers to a single order belonging to a Subaccount.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUBACCOUNT_ID_FIELD_NUMBER: builtins.int
    CLIENT_ID_FIELD_NUMBER: builtins.int
    ORDER_FLAGS_FIELD_NUMBER: builtins.int
    CLOB_PAIR_ID_FIELD_NUMBER: builtins.int
    client_id: builtins.int
    """The client ID of this order, unique with respect to the specific
    sub account (I.E., the same subaccount can't have two orders with
    the same ClientId).
    """
    order_flags: builtins.int
    """order_flags represent order flags for the order. This field is invalid if
    it's greater than 127 (larger than one byte). Each bit in the first byte
    represents a different flag. Currently only two flags are supported.

    Starting from the bit after the most MSB (note that the MSB is used in
    proto varint encoding, and therefore cannot be used): Bit 1 is set if this
    order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this
    order is a Conditional order (0x20, or 32 as a uint8).

    If neither bit is set, the order is assumed to be a Short-Term order.

    If both bits are set or bits other than the 2nd and 3rd are set, the order
    ID is invalid.
    """
    clob_pair_id: builtins.int
    """ID of the CLOB the order is created for."""
    @property
    def subaccount_id(self) -> dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId:
        """The subaccount ID that opened this order.
        Note that this field has `gogoproto.nullable = false` so that it is
        generated as a value instead of a pointer. This is because the `OrderId`
        proto is used as a key within maps, and map comparisons will compare
        pointers for equality (when the desired behavior is to compare the values).
        """

    def __init__(
        self,
        *,
        subaccount_id: dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId | None = ...,
        client_id: builtins.int = ...,
        order_flags: builtins.int = ...,
        clob_pair_id: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["subaccount_id", b"subaccount_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["client_id", b"client_id", "clob_pair_id", b"clob_pair_id", "order_flags", b"order_flags", "subaccount_id", b"subaccount_id"]) -> None: ...

global___IndexerOrderId = IndexerOrderId

@typing.final
class IndexerOrder(google.protobuf.message.Message):
    """IndexerOrderV1 represents a single order belonging to a `Subaccount`
    for a particular `ClobPair`.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Side:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SideEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[IndexerOrder._Side.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SIDE_UNSPECIFIED: IndexerOrder._Side.ValueType  # 0
        """Default value. This value is invalid and unused."""
        SIDE_BUY: IndexerOrder._Side.ValueType  # 1
        """SIDE_BUY is used to represent a BUY order."""
        SIDE_SELL: IndexerOrder._Side.ValueType  # 2
        """SIDE_SELL is used to represent a SELL order."""

    class Side(_Side, metaclass=_SideEnumTypeWrapper):
        """Represents the side of the orderbook the order will be placed on.
        Note that Side.SIDE_UNSPECIFIED is an invalid order and cannot be
        placed on the orderbook.
        """

    SIDE_UNSPECIFIED: IndexerOrder.Side.ValueType  # 0
    """Default value. This value is invalid and unused."""
    SIDE_BUY: IndexerOrder.Side.ValueType  # 1
    """SIDE_BUY is used to represent a BUY order."""
    SIDE_SELL: IndexerOrder.Side.ValueType  # 2
    """SIDE_SELL is used to represent a SELL order."""

    class _TimeInForce:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _TimeInForceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[IndexerOrder._TimeInForce.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        TIME_IN_FORCE_UNSPECIFIED: IndexerOrder._TimeInForce.ValueType  # 0
        """TIME_IN_FORCE_UNSPECIFIED represents the default behavior where an
        order will first match with existing orders on the book, and any
        remaining size will be added to the book as a maker order.
        """
        TIME_IN_FORCE_IOC: IndexerOrder._TimeInForce.ValueType  # 1
        """TIME_IN_FORCE_IOC enforces that an order only be matched with
        maker orders on the book. If the order has remaining size after
        matching with existing orders on the book, the remaining size
        is not placed on the book.
        """
        TIME_IN_FORCE_POST_ONLY: IndexerOrder._TimeInForce.ValueType  # 2
        """TIME_IN_FORCE_POST_ONLY enforces that an order only be placed
        on the book as a maker order. Note this means that validators will cancel
        any newly-placed post only orders that would cross with other maker
        orders.
        """
        TIME_IN_FORCE_FILL_OR_KILL: IndexerOrder._TimeInForce.ValueType  # 3
        """TIME_IN_FORCE_FILL_OR_KILL enforces that an order will either be filled
        completely and immediately by maker orders on the book or canceled if the
        entire amount canâ€˜t be matched.
        """

    class TimeInForce(_TimeInForce, metaclass=_TimeInForceEnumTypeWrapper):
        """TimeInForce indicates how long an order will remain active before it
        is executed or expires.
        """

    TIME_IN_FORCE_UNSPECIFIED: IndexerOrder.TimeInForce.ValueType  # 0
    """TIME_IN_FORCE_UNSPECIFIED represents the default behavior where an
    order will first match with existing orders on the book, and any
    remaining size will be added to the book as a maker order.
    """
    TIME_IN_FORCE_IOC: IndexerOrder.TimeInForce.ValueType  # 1
    """TIME_IN_FORCE_IOC enforces that an order only be matched with
    maker orders on the book. If the order has remaining size after
    matching with existing orders on the book, the remaining size
    is not placed on the book.
    """
    TIME_IN_FORCE_POST_ONLY: IndexerOrder.TimeInForce.ValueType  # 2
    """TIME_IN_FORCE_POST_ONLY enforces that an order only be placed
    on the book as a maker order. Note this means that validators will cancel
    any newly-placed post only orders that would cross with other maker
    orders.
    """
    TIME_IN_FORCE_FILL_OR_KILL: IndexerOrder.TimeInForce.ValueType  # 3
    """TIME_IN_FORCE_FILL_OR_KILL enforces that an order will either be filled
    completely and immediately by maker orders on the book or canceled if the
    entire amount canâ€˜t be matched.
    """

    class _ConditionType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ConditionTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[IndexerOrder._ConditionType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        CONDITION_TYPE_UNSPECIFIED: IndexerOrder._ConditionType.ValueType  # 0
        """CONDITION_TYPE_UNSPECIFIED represents the default behavior where an
        order will be placed immediately on the orderbook.
        """
        CONDITION_TYPE_STOP_LOSS: IndexerOrder._ConditionType.ValueType  # 1
        """CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will
        trigger when the oracle price moves at or above the trigger price for
        buys, and at or below the trigger price for sells.
        """
        CONDITION_TYPE_TAKE_PROFIT: IndexerOrder._ConditionType.ValueType  # 2
        """CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit
        order will trigger when the oracle price moves at or below the trigger
        price for buys and at or above the trigger price for sells.
        """

    class ConditionType(_ConditionType, metaclass=_ConditionTypeEnumTypeWrapper): ...
    CONDITION_TYPE_UNSPECIFIED: IndexerOrder.ConditionType.ValueType  # 0
    """CONDITION_TYPE_UNSPECIFIED represents the default behavior where an
    order will be placed immediately on the orderbook.
    """
    CONDITION_TYPE_STOP_LOSS: IndexerOrder.ConditionType.ValueType  # 1
    """CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will
    trigger when the oracle price moves at or above the trigger price for
    buys, and at or below the trigger price for sells.
    """
    CONDITION_TYPE_TAKE_PROFIT: IndexerOrder.ConditionType.ValueType  # 2
    """CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit
    order will trigger when the oracle price moves at or below the trigger
    price for buys and at or above the trigger price for sells.
    """

    ORDER_ID_FIELD_NUMBER: builtins.int
    SIDE_FIELD_NUMBER: builtins.int
    QUANTUMS_FIELD_NUMBER: builtins.int
    SUBTICKS_FIELD_NUMBER: builtins.int
    GOOD_TIL_BLOCK_FIELD_NUMBER: builtins.int
    GOOD_TIL_BLOCK_TIME_FIELD_NUMBER: builtins.int
    TIME_IN_FORCE_FIELD_NUMBER: builtins.int
    REDUCE_ONLY_FIELD_NUMBER: builtins.int
    CLIENT_METADATA_FIELD_NUMBER: builtins.int
    CONDITION_TYPE_FIELD_NUMBER: builtins.int
    CONDITIONAL_ORDER_TRIGGER_SUBTICKS_FIELD_NUMBER: builtins.int
    side: global___IndexerOrder.Side.ValueType
    quantums: builtins.int
    """The size of this order in base quantums. Must be a multiple of
    `ClobPair.StepBaseQuantums` (where `ClobPair.Id = orderId.ClobPairId`).
    """
    subticks: builtins.int
    """The price level that this order will be placed at on the orderbook,
    in subticks. Must be a multiple of ClobPair.SubticksPerTick
    (where `ClobPair.Id = orderId.ClobPairId`).
    """
    good_til_block: builtins.int
    """The last block this order can be executed at (after which it will be
    unfillable). Used only for Short-Term orders. If this value is non-zero
    then the order is assumed to be a Short-Term order.
    """
    good_til_block_time: builtins.int
    """good_til_block_time represents the unix timestamp (in seconds) at which a
    stateful order will be considered expired. The
    good_til_block_time is always evaluated against the previous block's
    `BlockTime` instead of the block in which the order is committed. If this
    value is non-zero then the order is assumed to be a stateful or
    conditional order.
    """
    time_in_force: global___IndexerOrder.TimeInForce.ValueType
    """The time in force of this order."""
    reduce_only: builtins.bool
    """Enforces that the order can only reduce the size of an existing position.
    If a ReduceOnly order would change the side of the existing position,
    its size is reduced to that of the remaining size of the position.
    If existing orders on the book with ReduceOnly
    would already close the position, the least aggressive (out-of-the-money)
    ReduceOnly orders are resized and canceled first.
    """
    client_metadata: builtins.int
    """Set of bit flags set arbitrarily by clients and ignored by the protocol.
    Used by indexer to infer information about a placed order.
    """
    condition_type: global___IndexerOrder.ConditionType.ValueType
    conditional_order_trigger_subticks: builtins.int
    """conditional_order_trigger_subticks represents the price at which this order
    will be triggered. If the condition_type is CONDITION_TYPE_UNSPECIFIED,
    this value is enforced to be 0. If this value is nonzero, condition_type
    cannot be CONDITION_TYPE_UNSPECIFIED. Value is in subticks.
    Must be a multiple of ClobPair.SubticksPerTick (where `ClobPair.Id =
    orderId.ClobPairId`).
    """
    @property
    def order_id(self) -> global___IndexerOrderId:
        """The unique ID of this order. Meant to be unique across all orders."""

    def __init__(
        self,
        *,
        order_id: global___IndexerOrderId | None = ...,
        side: global___IndexerOrder.Side.ValueType = ...,
        quantums: builtins.int = ...,
        subticks: builtins.int = ...,
        good_til_block: builtins.int = ...,
        good_til_block_time: builtins.int = ...,
        time_in_force: global___IndexerOrder.TimeInForce.ValueType = ...,
        reduce_only: builtins.bool = ...,
        client_metadata: builtins.int = ...,
        condition_type: global___IndexerOrder.ConditionType.ValueType = ...,
        conditional_order_trigger_subticks: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["good_til_block", b"good_til_block", "good_til_block_time", b"good_til_block_time", "good_til_oneof", b"good_til_oneof", "order_id", b"order_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["client_metadata", b"client_metadata", "condition_type", b"condition_type", "conditional_order_trigger_subticks", b"conditional_order_trigger_subticks", "good_til_block", b"good_til_block", "good_til_block_time", b"good_til_block_time", "good_til_oneof", b"good_til_oneof", "order_id", b"order_id", "quantums", b"quantums", "reduce_only", b"reduce_only", "side", b"side", "subticks", b"subticks", "time_in_force", b"time_in_force"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["good_til_oneof", b"good_til_oneof"]) -> typing.Literal["good_til_block", "good_til_block_time"] | None: ...

global___IndexerOrder = IndexerOrder
