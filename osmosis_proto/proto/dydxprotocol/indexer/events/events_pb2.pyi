"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import dydxprotocol.indexer.protocol.v1.clob_pb2
import dydxprotocol.indexer.protocol.v1.perpetual_pb2
import dydxprotocol.indexer.protocol.v1.subaccount_pb2
import dydxprotocol.indexer.protocol.v1.vault_pb2
import dydxprotocol.indexer.shared.removal_reason_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class FundingUpdateV1(google.protobuf.message.Message):
    """Do not make any breaking changes to these protos, a new version should be
    created if a breaking change is needed.

    FundingUpdate is used for funding update events and includes a funding
    value and an optional funding index that correspond to a perpetual market.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PERPETUAL_ID_FIELD_NUMBER: builtins.int
    FUNDING_VALUE_PPM_FIELD_NUMBER: builtins.int
    FUNDING_INDEX_FIELD_NUMBER: builtins.int
    perpetual_id: builtins.int
    """The id of the perpetual market."""
    funding_value_ppm: builtins.int
    """funding value (in parts-per-million) can be premium vote, premium sample,
    or funding rate.
    """
    funding_index: builtins.bytes
    """funding index is required if and only if parent `FundingEvent` type is
    `TYPE_FUNDING_RATE_AND_INDEX`.
    """
    def __init__(
        self,
        *,
        perpetual_id: builtins.int = ...,
        funding_value_ppm: builtins.int = ...,
        funding_index: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["funding_index", b"funding_index", "funding_value_ppm", b"funding_value_ppm", "perpetual_id", b"perpetual_id"]) -> None: ...

global___FundingUpdateV1 = FundingUpdateV1

@typing.final
class FundingEventV1(google.protobuf.message.Message):
    """FundingEvent message contains a list of per-market funding values. The
    funding values in the list is of the same type and the types are: which can
    have one of the following types:
    1. Premium vote: votes on the premium values injected by block proposers.
    2. Premium sample: combined value from all premium votes during a
       `funding-sample` epoch.
    3. Funding rate and index: final funding rate combining all premium samples
       during a `funding-tick` epoch and funding index accordingly updated with
       `funding rate * price`.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Type:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[FundingEventV1._Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        TYPE_UNSPECIFIED: FundingEventV1._Type.ValueType  # 0
        """Unspecified type."""
        TYPE_PREMIUM_SAMPLE: FundingEventV1._Type.ValueType  # 1
        """Premium sample is the combined value from all premium votes during a
        `funding-sample` epoch.
        """
        TYPE_FUNDING_RATE_AND_INDEX: FundingEventV1._Type.ValueType  # 2
        """Funding rate is the final funding rate combining all premium samples
        during a `funding-tick` epoch.
        """
        TYPE_PREMIUM_VOTE: FundingEventV1._Type.ValueType  # 3
        """TODO(DEC-1513): Investigate whether premium vote values need to be
        sent to indexer.
        """

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        """Type is the type for funding values."""

    TYPE_UNSPECIFIED: FundingEventV1.Type.ValueType  # 0
    """Unspecified type."""
    TYPE_PREMIUM_SAMPLE: FundingEventV1.Type.ValueType  # 1
    """Premium sample is the combined value from all premium votes during a
    `funding-sample` epoch.
    """
    TYPE_FUNDING_RATE_AND_INDEX: FundingEventV1.Type.ValueType  # 2
    """Funding rate is the final funding rate combining all premium samples
    during a `funding-tick` epoch.
    """
    TYPE_PREMIUM_VOTE: FundingEventV1.Type.ValueType  # 3
    """TODO(DEC-1513): Investigate whether premium vote values need to be
    sent to indexer.
    """

    UPDATES_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    type: global___FundingEventV1.Type.ValueType
    """type stores the type of funding updates."""
    @property
    def updates(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FundingUpdateV1]:
        """updates is a list of per-market funding updates for all existing perpetual
        markets. The list is sorted by `perpetualId`s which are unique.
        """

    def __init__(
        self,
        *,
        updates: collections.abc.Iterable[global___FundingUpdateV1] | None = ...,
        type: global___FundingEventV1.Type.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["type", b"type", "updates", b"updates"]) -> None: ...

global___FundingEventV1 = FundingEventV1

@typing.final
class MarketEventV1(google.protobuf.message.Message):
    """MarketEvent message contains all the information about a market event on
    the dYdX chain.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MARKET_ID_FIELD_NUMBER: builtins.int
    PRICE_UPDATE_FIELD_NUMBER: builtins.int
    MARKET_CREATE_FIELD_NUMBER: builtins.int
    MARKET_MODIFY_FIELD_NUMBER: builtins.int
    market_id: builtins.int
    """market id."""
    @property
    def price_update(self) -> global___MarketPriceUpdateEventV1: ...
    @property
    def market_create(self) -> global___MarketCreateEventV1: ...
    @property
    def market_modify(self) -> global___MarketModifyEventV1: ...
    def __init__(
        self,
        *,
        market_id: builtins.int = ...,
        price_update: global___MarketPriceUpdateEventV1 | None = ...,
        market_create: global___MarketCreateEventV1 | None = ...,
        market_modify: global___MarketModifyEventV1 | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["event", b"event", "market_create", b"market_create", "market_modify", b"market_modify", "price_update", b"price_update"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["event", b"event", "market_create", b"market_create", "market_id", b"market_id", "market_modify", b"market_modify", "price_update", b"price_update"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["event", b"event"]) -> typing.Literal["price_update", "market_create", "market_modify"] | None: ...

global___MarketEventV1 = MarketEventV1

@typing.final
class MarketPriceUpdateEventV1(google.protobuf.message.Message):
    """MarketPriceUpdateEvent message contains all the information about a price
    update on the dYdX chain.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PRICE_WITH_EXPONENT_FIELD_NUMBER: builtins.int
    price_with_exponent: builtins.int
    """price_with_exponent. Multiply by 10 ^ Exponent to get the human readable
    price in dollars. For example if `Exponent == -5` then a `exponent_price`
    of `1,000,000,000` represents â€œ$10,000`.
    """
    def __init__(
        self,
        *,
        price_with_exponent: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["price_with_exponent", b"price_with_exponent"]) -> None: ...

global___MarketPriceUpdateEventV1 = MarketPriceUpdateEventV1

@typing.final
class MarketBaseEventV1(google.protobuf.message.Message):
    """shared fields between MarketCreateEvent and MarketModifyEvent"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PAIR_FIELD_NUMBER: builtins.int
    MIN_PRICE_CHANGE_PPM_FIELD_NUMBER: builtins.int
    pair: builtins.str
    """String representation of the market pair, e.g. `BTC-USD`"""
    min_price_change_ppm: builtins.int
    """The minimum allowable change in the Price value for a given update.
    Measured as 1e-6.
    """
    def __init__(
        self,
        *,
        pair: builtins.str = ...,
        min_price_change_ppm: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["min_price_change_ppm", b"min_price_change_ppm", "pair", b"pair"]) -> None: ...

global___MarketBaseEventV1 = MarketBaseEventV1

@typing.final
class MarketCreateEventV1(google.protobuf.message.Message):
    """MarketCreateEvent message contains all the information about a new market on
    the dYdX chain.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BASE_FIELD_NUMBER: builtins.int
    EXPONENT_FIELD_NUMBER: builtins.int
    exponent: builtins.int
    """Static value. The exponent of the price.
    For example if Exponent == -5 then a `exponent_price` of 1,000,000,000
    represents $10,000. Therefore 10 ^ Exponent represents the smallest
    price step (in dollars) that can be recorded.
    """
    @property
    def base(self) -> global___MarketBaseEventV1: ...
    def __init__(
        self,
        *,
        base: global___MarketBaseEventV1 | None = ...,
        exponent: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["base", b"base"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["base", b"base", "exponent", b"exponent"]) -> None: ...

global___MarketCreateEventV1 = MarketCreateEventV1

@typing.final
class MarketModifyEventV1(google.protobuf.message.Message):
    """MarketModifyEvent message contains all the information about a market update
    on the dYdX chain
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BASE_FIELD_NUMBER: builtins.int
    @property
    def base(self) -> global___MarketBaseEventV1: ...
    def __init__(
        self,
        *,
        base: global___MarketBaseEventV1 | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["base", b"base"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["base", b"base"]) -> None: ...

global___MarketModifyEventV1 = MarketModifyEventV1

@typing.final
class SourceOfFunds(google.protobuf.message.Message):
    """SourceOfFunds is the source of funds in a transfer event."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUBACCOUNT_ID_FIELD_NUMBER: builtins.int
    ADDRESS_FIELD_NUMBER: builtins.int
    address: builtins.str
    @property
    def subaccount_id(self) -> dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId: ...
    def __init__(
        self,
        *,
        subaccount_id: dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId | None = ...,
        address: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["address", b"address", "source", b"source", "subaccount_id", b"subaccount_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["address", b"address", "source", b"source", "subaccount_id", b"subaccount_id"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["source", b"source"]) -> typing.Literal["subaccount_id", "address"] | None: ...

global___SourceOfFunds = SourceOfFunds

@typing.final
class TransferEventV1(google.protobuf.message.Message):
    """TransferEvent message contains all the information about a transfer,
    deposit-to-subaccount, or withdraw-from-subaccount on the dYdX chain.
    When a subaccount is involved, a SubaccountUpdateEvent message will
    be produced with the updated asset positions.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SENDER_SUBACCOUNT_ID_FIELD_NUMBER: builtins.int
    RECIPIENT_SUBACCOUNT_ID_FIELD_NUMBER: builtins.int
    ASSET_ID_FIELD_NUMBER: builtins.int
    AMOUNT_FIELD_NUMBER: builtins.int
    SENDER_FIELD_NUMBER: builtins.int
    RECIPIENT_FIELD_NUMBER: builtins.int
    asset_id: builtins.int
    """Id of the asset transfered."""
    amount: builtins.int
    """The amount of asset in quantums to transfer."""
    @property
    def sender_subaccount_id(self) -> dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId: ...
    @property
    def recipient_subaccount_id(self) -> dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId: ...
    @property
    def sender(self) -> global___SourceOfFunds:
        """The sender is one of below
        - a subaccount ID (in transfer and withdraw events).
        - a wallet address (in deposit events).
        """

    @property
    def recipient(self) -> global___SourceOfFunds:
        """The recipient is one of below
        - a subaccount ID (in transfer and deposit events).
        - a wallet address (in withdraw events).
        """

    def __init__(
        self,
        *,
        sender_subaccount_id: dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId | None = ...,
        recipient_subaccount_id: dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId | None = ...,
        asset_id: builtins.int = ...,
        amount: builtins.int = ...,
        sender: global___SourceOfFunds | None = ...,
        recipient: global___SourceOfFunds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["recipient", b"recipient", "recipient_subaccount_id", b"recipient_subaccount_id", "sender", b"sender", "sender_subaccount_id", b"sender_subaccount_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["amount", b"amount", "asset_id", b"asset_id", "recipient", b"recipient", "recipient_subaccount_id", b"recipient_subaccount_id", "sender", b"sender", "sender_subaccount_id", b"sender_subaccount_id"]) -> None: ...

global___TransferEventV1 = TransferEventV1

@typing.final
class OrderFillEventV1(google.protobuf.message.Message):
    """OrderFillEvent message contains all the information from an order match in
    the dYdX chain. This includes the maker/taker orders that matched and the
    amount filled.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MAKER_ORDER_FIELD_NUMBER: builtins.int
    ORDER_FIELD_NUMBER: builtins.int
    LIQUIDATION_ORDER_FIELD_NUMBER: builtins.int
    FILL_AMOUNT_FIELD_NUMBER: builtins.int
    MAKER_FEE_FIELD_NUMBER: builtins.int
    TAKER_FEE_FIELD_NUMBER: builtins.int
    TOTAL_FILLED_MAKER_FIELD_NUMBER: builtins.int
    TOTAL_FILLED_TAKER_FIELD_NUMBER: builtins.int
    AFFILIATE_REV_SHARE_FIELD_NUMBER: builtins.int
    fill_amount: builtins.int
    """Fill amount in base quantums."""
    maker_fee: builtins.int
    """Maker fee in USDC quantums."""
    taker_fee: builtins.int
    """Taker fee in USDC quantums. If the taker order is a liquidation, then this
    represents the special liquidation fee, not the standard taker fee.
    """
    total_filled_maker: builtins.int
    """Total filled of the maker order in base quantums."""
    total_filled_taker: builtins.int
    """Total filled of the taker order in base quantums."""
    affiliate_rev_share: builtins.int
    """rev share for affiliates in USDC quantums."""
    @property
    def maker_order(self) -> dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrder: ...
    @property
    def order(self) -> dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrder: ...
    @property
    def liquidation_order(self) -> global___LiquidationOrderV1: ...
    def __init__(
        self,
        *,
        maker_order: dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrder | None = ...,
        order: dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrder | None = ...,
        liquidation_order: global___LiquidationOrderV1 | None = ...,
        fill_amount: builtins.int = ...,
        maker_fee: builtins.int = ...,
        taker_fee: builtins.int = ...,
        total_filled_maker: builtins.int = ...,
        total_filled_taker: builtins.int = ...,
        affiliate_rev_share: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["liquidation_order", b"liquidation_order", "maker_order", b"maker_order", "order", b"order", "taker_order", b"taker_order"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["affiliate_rev_share", b"affiliate_rev_share", "fill_amount", b"fill_amount", "liquidation_order", b"liquidation_order", "maker_fee", b"maker_fee", "maker_order", b"maker_order", "order", b"order", "taker_fee", b"taker_fee", "taker_order", b"taker_order", "total_filled_maker", b"total_filled_maker", "total_filled_taker", b"total_filled_taker"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["taker_order", b"taker_order"]) -> typing.Literal["order", "liquidation_order"] | None: ...

global___OrderFillEventV1 = OrderFillEventV1

@typing.final
class DeleveragingEventV1(google.protobuf.message.Message):
    """DeleveragingEvent message contains all the information for a deleveraging
    on the dYdX chain. This includes the liquidated/offsetting subaccounts and
    the amount filled.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LIQUIDATED_FIELD_NUMBER: builtins.int
    OFFSETTING_FIELD_NUMBER: builtins.int
    PERPETUAL_ID_FIELD_NUMBER: builtins.int
    FILL_AMOUNT_FIELD_NUMBER: builtins.int
    TOTAL_QUOTE_QUANTUMS_FIELD_NUMBER: builtins.int
    IS_BUY_FIELD_NUMBER: builtins.int
    IS_FINAL_SETTLEMENT_FIELD_NUMBER: builtins.int
    perpetual_id: builtins.int
    """The ID of the perpetual that was liquidated."""
    fill_amount: builtins.int
    """The amount filled between the liquidated and offsetting position, in
    base quantums.
    """
    total_quote_quantums: builtins.int
    """Total quote quantums filled."""
    is_buy: builtins.bool
    """`true` if liquidating a short position, `false` otherwise."""
    is_final_settlement: builtins.bool
    """`true` if the deleveraging event is for final settlement, indicating
    the match occurred at the oracle price rather than bankruptcy price.
    When this flag is `false`, the fill price is the bankruptcy price
    of the liquidated subaccount.
    """
    @property
    def liquidated(self) -> dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId:
        """ID of the subaccount that was liquidated."""

    @property
    def offsetting(self) -> dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId:
        """ID of the subaccount that was used to offset the position."""

    def __init__(
        self,
        *,
        liquidated: dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId | None = ...,
        offsetting: dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId | None = ...,
        perpetual_id: builtins.int = ...,
        fill_amount: builtins.int = ...,
        total_quote_quantums: builtins.int = ...,
        is_buy: builtins.bool = ...,
        is_final_settlement: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["liquidated", b"liquidated", "offsetting", b"offsetting"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["fill_amount", b"fill_amount", "is_buy", b"is_buy", "is_final_settlement", b"is_final_settlement", "liquidated", b"liquidated", "offsetting", b"offsetting", "perpetual_id", b"perpetual_id", "total_quote_quantums", b"total_quote_quantums"]) -> None: ...

global___DeleveragingEventV1 = DeleveragingEventV1

@typing.final
class LiquidationOrderV1(google.protobuf.message.Message):
    """LiquidationOrder represents the liquidation taker order to be included in a
    liquidation order fill event.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LIQUIDATED_FIELD_NUMBER: builtins.int
    CLOB_PAIR_ID_FIELD_NUMBER: builtins.int
    PERPETUAL_ID_FIELD_NUMBER: builtins.int
    TOTAL_SIZE_FIELD_NUMBER: builtins.int
    IS_BUY_FIELD_NUMBER: builtins.int
    SUBTICKS_FIELD_NUMBER: builtins.int
    clob_pair_id: builtins.int
    """The ID of the clob pair involved in the liquidation."""
    perpetual_id: builtins.int
    """The ID of the perpetual involved in the liquidation."""
    total_size: builtins.int
    """The total size of the liquidation order including any unfilled size,
    in base quantums.
    """
    is_buy: builtins.bool
    """`true` if liquidating a short position, `false` otherwise."""
    subticks: builtins.int
    """The fillable price in subticks.
    This represents the lower-price-bound for liquidating longs
    and the upper-price-bound for liquidating shorts.
    Must be a multiple of ClobPair.SubticksPerTick
    (where `ClobPair.Id = orderId.ClobPairId`).
    """
    @property
    def liquidated(self) -> dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId:
        """ID of the subaccount that was liquidated."""

    def __init__(
        self,
        *,
        liquidated: dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId | None = ...,
        clob_pair_id: builtins.int = ...,
        perpetual_id: builtins.int = ...,
        total_size: builtins.int = ...,
        is_buy: builtins.bool = ...,
        subticks: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["liquidated", b"liquidated"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["clob_pair_id", b"clob_pair_id", "is_buy", b"is_buy", "liquidated", b"liquidated", "perpetual_id", b"perpetual_id", "subticks", b"subticks", "total_size", b"total_size"]) -> None: ...

global___LiquidationOrderV1 = LiquidationOrderV1

@typing.final
class SubaccountUpdateEventV1(google.protobuf.message.Message):
    """SubaccountUpdateEvent message contains information about an update to a
    subaccount in the dYdX chain. This includes the list of updated perpetual
    and asset positions for the subaccount.
    Note: This event message will contain all the updates to a subaccount
    at the end of a block which is why multiple asset/perpetual position
    updates may exist.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUBACCOUNT_ID_FIELD_NUMBER: builtins.int
    UPDATED_PERPETUAL_POSITIONS_FIELD_NUMBER: builtins.int
    UPDATED_ASSET_POSITIONS_FIELD_NUMBER: builtins.int
    @property
    def subaccount_id(self) -> dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId: ...
    @property
    def updated_perpetual_positions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerPerpetualPosition]:
        """updated_perpetual_positions will each be for unique perpetuals."""

    @property
    def updated_asset_positions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerAssetPosition]:
        """updated_asset_positions will each be for unique assets."""

    def __init__(
        self,
        *,
        subaccount_id: dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerSubaccountId | None = ...,
        updated_perpetual_positions: collections.abc.Iterable[dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerPerpetualPosition] | None = ...,
        updated_asset_positions: collections.abc.Iterable[dydxprotocol.indexer.protocol.v1.subaccount_pb2.IndexerAssetPosition] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["subaccount_id", b"subaccount_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["subaccount_id", b"subaccount_id", "updated_asset_positions", b"updated_asset_positions", "updated_perpetual_positions", b"updated_perpetual_positions"]) -> None: ...

global___SubaccountUpdateEventV1 = SubaccountUpdateEventV1

@typing.final
class StatefulOrderEventV1(google.protobuf.message.Message):
    """StatefulOrderEvent message contains information about a change to a stateful
    order. Currently, this is either the placement of a long-term order, the
    placement or triggering of a conditional order, or the removal of a
    stateful order.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class StatefulOrderPlacementV1(google.protobuf.message.Message):
        """A stateful order placement contains an order.
        Deprecated in favor of LongTermOrderPlacementV1.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ORDER_FIELD_NUMBER: builtins.int
        @property
        def order(self) -> dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrder: ...
        def __init__(
            self,
            *,
            order: dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrder | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["order", b"order"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["order", b"order"]) -> None: ...

    @typing.final
    class StatefulOrderRemovalV1(google.protobuf.message.Message):
        """A stateful order removal contains the id of an order that was already
        placed and is now removed and the reason for the removal.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        REMOVED_ORDER_ID_FIELD_NUMBER: builtins.int
        REASON_FIELD_NUMBER: builtins.int
        reason: dydxprotocol.indexer.shared.removal_reason_pb2.OrderRemovalReason.ValueType
        @property
        def removed_order_id(self) -> dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrderId: ...
        def __init__(
            self,
            *,
            removed_order_id: dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrderId | None = ...,
            reason: dydxprotocol.indexer.shared.removal_reason_pb2.OrderRemovalReason.ValueType = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["removed_order_id", b"removed_order_id"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["reason", b"reason", "removed_order_id", b"removed_order_id"]) -> None: ...

    @typing.final
    class ConditionalOrderPlacementV1(google.protobuf.message.Message):
        """A conditional order placement contains an order. The order is newly-placed
        and untriggered when this event is emitted.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ORDER_FIELD_NUMBER: builtins.int
        @property
        def order(self) -> dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrder: ...
        def __init__(
            self,
            *,
            order: dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrder | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["order", b"order"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["order", b"order"]) -> None: ...

    @typing.final
    class ConditionalOrderTriggeredV1(google.protobuf.message.Message):
        """A conditional order trigger event contains an order id and is emitted when
        an order is triggered.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TRIGGERED_ORDER_ID_FIELD_NUMBER: builtins.int
        @property
        def triggered_order_id(self) -> dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrderId: ...
        def __init__(
            self,
            *,
            triggered_order_id: dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrderId | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["triggered_order_id", b"triggered_order_id"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["triggered_order_id", b"triggered_order_id"]) -> None: ...

    @typing.final
    class LongTermOrderPlacementV1(google.protobuf.message.Message):
        """A long term order placement contains an order."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ORDER_FIELD_NUMBER: builtins.int
        @property
        def order(self) -> dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrder: ...
        def __init__(
            self,
            *,
            order: dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrder | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["order", b"order"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["order", b"order"]) -> None: ...

    @typing.final
    class LongTermOrderReplacementV1(google.protobuf.message.Message):
        """A long term order replacement contains an old order ID and the new order."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        OLD_ORDER_ID_FIELD_NUMBER: builtins.int
        ORDER_FIELD_NUMBER: builtins.int
        @property
        def old_order_id(self) -> dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrderId:
            """vault replaces orders with a different order ID"""

        @property
        def order(self) -> dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrder: ...
        def __init__(
            self,
            *,
            old_order_id: dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrderId | None = ...,
            order: dydxprotocol.indexer.protocol.v1.clob_pb2.IndexerOrder | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["old_order_id", b"old_order_id", "order", b"order"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["old_order_id", b"old_order_id", "order", b"order"]) -> None: ...

    ORDER_PLACE_FIELD_NUMBER: builtins.int
    ORDER_REMOVAL_FIELD_NUMBER: builtins.int
    CONDITIONAL_ORDER_PLACEMENT_FIELD_NUMBER: builtins.int
    CONDITIONAL_ORDER_TRIGGERED_FIELD_NUMBER: builtins.int
    LONG_TERM_ORDER_PLACEMENT_FIELD_NUMBER: builtins.int
    ORDER_REPLACEMENT_FIELD_NUMBER: builtins.int
    @property
    def order_place(self) -> global___StatefulOrderEventV1.StatefulOrderPlacementV1:
        """Deprecated in favor of long_term_order_placement"""

    @property
    def order_removal(self) -> global___StatefulOrderEventV1.StatefulOrderRemovalV1: ...
    @property
    def conditional_order_placement(self) -> global___StatefulOrderEventV1.ConditionalOrderPlacementV1: ...
    @property
    def conditional_order_triggered(self) -> global___StatefulOrderEventV1.ConditionalOrderTriggeredV1: ...
    @property
    def long_term_order_placement(self) -> global___StatefulOrderEventV1.LongTermOrderPlacementV1: ...
    @property
    def order_replacement(self) -> global___StatefulOrderEventV1.LongTermOrderReplacementV1: ...
    def __init__(
        self,
        *,
        order_place: global___StatefulOrderEventV1.StatefulOrderPlacementV1 | None = ...,
        order_removal: global___StatefulOrderEventV1.StatefulOrderRemovalV1 | None = ...,
        conditional_order_placement: global___StatefulOrderEventV1.ConditionalOrderPlacementV1 | None = ...,
        conditional_order_triggered: global___StatefulOrderEventV1.ConditionalOrderTriggeredV1 | None = ...,
        long_term_order_placement: global___StatefulOrderEventV1.LongTermOrderPlacementV1 | None = ...,
        order_replacement: global___StatefulOrderEventV1.LongTermOrderReplacementV1 | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["conditional_order_placement", b"conditional_order_placement", "conditional_order_triggered", b"conditional_order_triggered", "event", b"event", "long_term_order_placement", b"long_term_order_placement", "order_place", b"order_place", "order_removal", b"order_removal", "order_replacement", b"order_replacement"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["conditional_order_placement", b"conditional_order_placement", "conditional_order_triggered", b"conditional_order_triggered", "event", b"event", "long_term_order_placement", b"long_term_order_placement", "order_place", b"order_place", "order_removal", b"order_removal", "order_replacement", b"order_replacement"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["event", b"event"]) -> typing.Literal["order_place", "order_removal", "conditional_order_placement", "conditional_order_triggered", "long_term_order_placement", "order_replacement"] | None: ...

global___StatefulOrderEventV1 = StatefulOrderEventV1

@typing.final
class AssetCreateEventV1(google.protobuf.message.Message):
    """AssetCreateEventV1 message contains all the information about an new Asset on
    the dYdX chain.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    SYMBOL_FIELD_NUMBER: builtins.int
    HAS_MARKET_FIELD_NUMBER: builtins.int
    MARKET_ID_FIELD_NUMBER: builtins.int
    ATOMIC_RESOLUTION_FIELD_NUMBER: builtins.int
    id: builtins.int
    """Unique, sequentially-generated."""
    symbol: builtins.str
    """The human readable symbol of the `Asset` (e.g. `USDC`, `ATOM`).
    Must be uppercase, unique and correspond to the canonical symbol of the
    full coin.
    """
    has_market: builtins.bool
    """`true` if this `Asset` has a valid `MarketId` value."""
    market_id: builtins.int
    """The `Id` of the `Market` associated with this `Asset`. It acts as the
    oracle price for the purposes of calculating collateral
    and margin requirements.
    """
    atomic_resolution: builtins.int
    """The exponent for converting an atomic amount (1 'quantum')
    to a full coin. For example, if `atomic_resolution = -8`
    then an `asset_position` with `base_quantums = 1e8` is equivalent to
    a position size of one full coin.
    """
    def __init__(
        self,
        *,
        id: builtins.int = ...,
        symbol: builtins.str = ...,
        has_market: builtins.bool = ...,
        market_id: builtins.int = ...,
        atomic_resolution: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["atomic_resolution", b"atomic_resolution", "has_market", b"has_market", "id", b"id", "market_id", b"market_id", "symbol", b"symbol"]) -> None: ...

global___AssetCreateEventV1 = AssetCreateEventV1

@typing.final
class PerpetualMarketCreateEventV1(google.protobuf.message.Message):
    """PerpetualMarketCreateEventV1 message contains all the information about a
    new Perpetual Market on the dYdX chain.
    Deprecated. See PerpetualMarketCreateEventV2 for the most up to date message
    for the event to create a new Perpetual Market.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    CLOB_PAIR_ID_FIELD_NUMBER: builtins.int
    TICKER_FIELD_NUMBER: builtins.int
    MARKET_ID_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    QUANTUM_CONVERSION_EXPONENT_FIELD_NUMBER: builtins.int
    ATOMIC_RESOLUTION_FIELD_NUMBER: builtins.int
    SUBTICKS_PER_TICK_FIELD_NUMBER: builtins.int
    STEP_BASE_QUANTUMS_FIELD_NUMBER: builtins.int
    LIQUIDITY_TIER_FIELD_NUMBER: builtins.int
    id: builtins.int
    """Unique Perpetual id.
    Defined in perpetuals.perpetual
    """
    clob_pair_id: builtins.int
    """Unique clob pair Id associated with this perpetual market
    Defined in clob.clob_pair
    """
    ticker: builtins.str
    """The name of the `Perpetual` (e.g. `BTC-USD`).
    Defined in perpetuals.perpetual
    """
    market_id: builtins.int
    """Unique id of market param associated with this perpetual market.
    Defined in perpetuals.perpetual
    """
    status: dydxprotocol.indexer.protocol.v1.clob_pb2.ClobPairStatus.ValueType
    """Status of the CLOB"""
    quantum_conversion_exponent: builtins.int
    """`10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum
    per Subtick.
    Defined in clob.clob_pair
    """
    atomic_resolution: builtins.int
    """The exponent for converting an atomic amount (`size = 1`)
    to a full coin. For example, if `AtomicResolution = -8`
    then a `PerpetualPosition` with `size = 1e8` is equivalent to
    a position size of one full coin.
    Defined in perpetuals.perpetual
    """
    subticks_per_tick: builtins.int
    """Defines the tick size of the orderbook by defining how many subticks
    are in one tick. That is, the subticks of any valid order must be a
    multiple of this value. Generally this value should start `>= 100`to
    allow room for decreasing it.
    Defined in clob.clob_pair
    """
    step_base_quantums: builtins.int
    """Minimum increment in the size of orders on the CLOB, in base quantums.
    Defined in clob.clob_pair
    """
    liquidity_tier: builtins.int
    """The liquidity_tier that this perpetual is associated with.
    Defined in perpetuals.perpetual
    """
    def __init__(
        self,
        *,
        id: builtins.int = ...,
        clob_pair_id: builtins.int = ...,
        ticker: builtins.str = ...,
        market_id: builtins.int = ...,
        status: dydxprotocol.indexer.protocol.v1.clob_pb2.ClobPairStatus.ValueType = ...,
        quantum_conversion_exponent: builtins.int = ...,
        atomic_resolution: builtins.int = ...,
        subticks_per_tick: builtins.int = ...,
        step_base_quantums: builtins.int = ...,
        liquidity_tier: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["atomic_resolution", b"atomic_resolution", "clob_pair_id", b"clob_pair_id", "id", b"id", "liquidity_tier", b"liquidity_tier", "market_id", b"market_id", "quantum_conversion_exponent", b"quantum_conversion_exponent", "status", b"status", "step_base_quantums", b"step_base_quantums", "subticks_per_tick", b"subticks_per_tick", "ticker", b"ticker"]) -> None: ...

global___PerpetualMarketCreateEventV1 = PerpetualMarketCreateEventV1

@typing.final
class PerpetualMarketCreateEventV2(google.protobuf.message.Message):
    """PerpetualMarketCreateEventV2 message contains all the information about a
    new Perpetual Market on the dYdX chain.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    CLOB_PAIR_ID_FIELD_NUMBER: builtins.int
    TICKER_FIELD_NUMBER: builtins.int
    MARKET_ID_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    QUANTUM_CONVERSION_EXPONENT_FIELD_NUMBER: builtins.int
    ATOMIC_RESOLUTION_FIELD_NUMBER: builtins.int
    SUBTICKS_PER_TICK_FIELD_NUMBER: builtins.int
    STEP_BASE_QUANTUMS_FIELD_NUMBER: builtins.int
    LIQUIDITY_TIER_FIELD_NUMBER: builtins.int
    MARKET_TYPE_FIELD_NUMBER: builtins.int
    id: builtins.int
    """Unique Perpetual id.
    Defined in perpetuals.perpetual
    """
    clob_pair_id: builtins.int
    """Unique clob pair Id associated with this perpetual market
    Defined in clob.clob_pair
    """
    ticker: builtins.str
    """The name of the `Perpetual` (e.g. `BTC-USD`).
    Defined in perpetuals.perpetual
    """
    market_id: builtins.int
    """Unique id of market param associated with this perpetual market.
    Defined in perpetuals.perpetual
    """
    status: dydxprotocol.indexer.protocol.v1.clob_pb2.ClobPairStatus.ValueType
    """Status of the CLOB"""
    quantum_conversion_exponent: builtins.int
    """`10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum
    per Subtick.
    Defined in clob.clob_pair
    """
    atomic_resolution: builtins.int
    """The exponent for converting an atomic amount (`size = 1`)
    to a full coin. For example, if `AtomicResolution = -8`
    then a `PerpetualPosition` with `size = 1e8` is equivalent to
    a position size of one full coin.
    Defined in perpetuals.perpetual
    """
    subticks_per_tick: builtins.int
    """Defines the tick size of the orderbook by defining how many subticks
    are in one tick. That is, the subticks of any valid order must be a
    multiple of this value. Generally this value should start `>= 100`to
    allow room for decreasing it.
    Defined in clob.clob_pair
    """
    step_base_quantums: builtins.int
    """Minimum increment in the size of orders on the CLOB, in base quantums.
    Defined in clob.clob_pair
    """
    liquidity_tier: builtins.int
    """The liquidity_tier that this perpetual is associated with.
    Defined in perpetuals.perpetual
    """
    market_type: dydxprotocol.indexer.protocol.v1.perpetual_pb2.PerpetualMarketType.ValueType
    """Market type of the perpetual."""
    def __init__(
        self,
        *,
        id: builtins.int = ...,
        clob_pair_id: builtins.int = ...,
        ticker: builtins.str = ...,
        market_id: builtins.int = ...,
        status: dydxprotocol.indexer.protocol.v1.clob_pb2.ClobPairStatus.ValueType = ...,
        quantum_conversion_exponent: builtins.int = ...,
        atomic_resolution: builtins.int = ...,
        subticks_per_tick: builtins.int = ...,
        step_base_quantums: builtins.int = ...,
        liquidity_tier: builtins.int = ...,
        market_type: dydxprotocol.indexer.protocol.v1.perpetual_pb2.PerpetualMarketType.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["atomic_resolution", b"atomic_resolution", "clob_pair_id", b"clob_pair_id", "id", b"id", "liquidity_tier", b"liquidity_tier", "market_id", b"market_id", "market_type", b"market_type", "quantum_conversion_exponent", b"quantum_conversion_exponent", "status", b"status", "step_base_quantums", b"step_base_quantums", "subticks_per_tick", b"subticks_per_tick", "ticker", b"ticker"]) -> None: ...

global___PerpetualMarketCreateEventV2 = PerpetualMarketCreateEventV2

@typing.final
class LiquidityTierUpsertEventV1(google.protobuf.message.Message):
    """LiquidityTierUpsertEventV1 message contains all the information to
    create/update a Liquidity Tier on the dYdX chain.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    INITIAL_MARGIN_PPM_FIELD_NUMBER: builtins.int
    MAINTENANCE_FRACTION_PPM_FIELD_NUMBER: builtins.int
    BASE_POSITION_NOTIONAL_FIELD_NUMBER: builtins.int
    id: builtins.int
    """Unique id."""
    name: builtins.str
    """The name of the tier purely for mnemonic purposes, e.g. "Gold"."""
    initial_margin_ppm: builtins.int
    """The margin fraction needed to open a position.
    In parts-per-million.
    """
    maintenance_fraction_ppm: builtins.int
    """The fraction of the initial-margin that the maintenance-margin is,
    e.g. 50%. In parts-per-million.
    """
    base_position_notional: builtins.int
    """The maximum position size at which the margin requirements are
    not increased over the default values. Above this position size,
    the margin requirements increase at a rate of sqrt(size).

    Deprecated since v3.x.
    """
    def __init__(
        self,
        *,
        id: builtins.int = ...,
        name: builtins.str = ...,
        initial_margin_ppm: builtins.int = ...,
        maintenance_fraction_ppm: builtins.int = ...,
        base_position_notional: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["base_position_notional", b"base_position_notional", "id", b"id", "initial_margin_ppm", b"initial_margin_ppm", "maintenance_fraction_ppm", b"maintenance_fraction_ppm", "name", b"name"]) -> None: ...

global___LiquidityTierUpsertEventV1 = LiquidityTierUpsertEventV1

@typing.final
class UpdateClobPairEventV1(google.protobuf.message.Message):
    """UpdateClobPairEventV1 message contains all the information about an update to
    a clob pair on the dYdX chain.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CLOB_PAIR_ID_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    QUANTUM_CONVERSION_EXPONENT_FIELD_NUMBER: builtins.int
    SUBTICKS_PER_TICK_FIELD_NUMBER: builtins.int
    STEP_BASE_QUANTUMS_FIELD_NUMBER: builtins.int
    clob_pair_id: builtins.int
    """Unique clob pair Id associated with this perpetual market
    Defined in clob.clob_pair
    """
    status: dydxprotocol.indexer.protocol.v1.clob_pb2.ClobPairStatus.ValueType
    """Status of the CLOB"""
    quantum_conversion_exponent: builtins.int
    """`10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum
    per Subtick.
    Defined in clob.clob_pair
    """
    subticks_per_tick: builtins.int
    """Defines the tick size of the orderbook by defining how many subticks
    are in one tick. That is, the subticks of any valid order must be a
    multiple of this value. Generally this value should start `>= 100`to
    allow room for decreasing it.
    Defined in clob.clob_pair
    """
    step_base_quantums: builtins.int
    """Minimum increment in the size of orders on the CLOB, in base quantums.
    Defined in clob.clob_pair
    """
    def __init__(
        self,
        *,
        clob_pair_id: builtins.int = ...,
        status: dydxprotocol.indexer.protocol.v1.clob_pb2.ClobPairStatus.ValueType = ...,
        quantum_conversion_exponent: builtins.int = ...,
        subticks_per_tick: builtins.int = ...,
        step_base_quantums: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["clob_pair_id", b"clob_pair_id", "quantum_conversion_exponent", b"quantum_conversion_exponent", "status", b"status", "step_base_quantums", b"step_base_quantums", "subticks_per_tick", b"subticks_per_tick"]) -> None: ...

global___UpdateClobPairEventV1 = UpdateClobPairEventV1

@typing.final
class UpdatePerpetualEventV1(google.protobuf.message.Message):
    """UpdatePerpetualEventV1 message contains all the information about an update
    to a perpetual on the dYdX chain.
    Deprecated. See UpdatePerpetualEventV2 for the most up to date message
    for the event to update a perpetual.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    TICKER_FIELD_NUMBER: builtins.int
    MARKET_ID_FIELD_NUMBER: builtins.int
    ATOMIC_RESOLUTION_FIELD_NUMBER: builtins.int
    LIQUIDITY_TIER_FIELD_NUMBER: builtins.int
    id: builtins.int
    """Unique Perpetual id.
    Defined in perpetuals.perpetual
    """
    ticker: builtins.str
    """The name of the `Perpetual` (e.g. `BTC-USD`).
    Defined in perpetuals.perpetual
    """
    market_id: builtins.int
    """Unique id of market param associated with this perpetual market.
    Defined in perpetuals.perpetual
    """
    atomic_resolution: builtins.int
    """The exponent for converting an atomic amount (`size = 1`)
    to a full coin. For example, if `AtomicResolution = -8`
    then a `PerpetualPosition` with `size = 1e8` is equivalent to
    a position size of one full coin.
    Defined in perpetuals.perpetual
    """
    liquidity_tier: builtins.int
    """The liquidity_tier that this perpetual is associated with.
    Defined in perpetuals.perpetual
    """
    def __init__(
        self,
        *,
        id: builtins.int = ...,
        ticker: builtins.str = ...,
        market_id: builtins.int = ...,
        atomic_resolution: builtins.int = ...,
        liquidity_tier: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["atomic_resolution", b"atomic_resolution", "id", b"id", "liquidity_tier", b"liquidity_tier", "market_id", b"market_id", "ticker", b"ticker"]) -> None: ...

global___UpdatePerpetualEventV1 = UpdatePerpetualEventV1

@typing.final
class UpdatePerpetualEventV2(google.protobuf.message.Message):
    """UpdatePerpetualEventV2 message contains all the information about an update
    to a perpetual on the dYdX chain.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    TICKER_FIELD_NUMBER: builtins.int
    MARKET_ID_FIELD_NUMBER: builtins.int
    ATOMIC_RESOLUTION_FIELD_NUMBER: builtins.int
    LIQUIDITY_TIER_FIELD_NUMBER: builtins.int
    MARKET_TYPE_FIELD_NUMBER: builtins.int
    id: builtins.int
    """Unique Perpetual id.
    Defined in perpetuals.perpetual
    """
    ticker: builtins.str
    """The name of the `Perpetual` (e.g. `BTC-USD`).
    Defined in perpetuals.perpetual
    """
    market_id: builtins.int
    """Unique id of market param associated with this perpetual market.
    Defined in perpetuals.perpetual
    """
    atomic_resolution: builtins.int
    """The exponent for converting an atomic amount (`size = 1`)
    to a full coin. For example, if `AtomicResolution = -8`
    then a `PerpetualPosition` with `size = 1e8` is equivalent to
    a position size of one full coin.
    Defined in perpetuals.perpetual
    """
    liquidity_tier: builtins.int
    """The liquidity_tier that this perpetual is associated with.
    Defined in perpetuals.perpetual
    """
    market_type: dydxprotocol.indexer.protocol.v1.perpetual_pb2.PerpetualMarketType.ValueType
    """Market type of the perpetual."""
    def __init__(
        self,
        *,
        id: builtins.int = ...,
        ticker: builtins.str = ...,
        market_id: builtins.int = ...,
        atomic_resolution: builtins.int = ...,
        liquidity_tier: builtins.int = ...,
        market_type: dydxprotocol.indexer.protocol.v1.perpetual_pb2.PerpetualMarketType.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["atomic_resolution", b"atomic_resolution", "id", b"id", "liquidity_tier", b"liquidity_tier", "market_id", b"market_id", "market_type", b"market_type", "ticker", b"ticker"]) -> None: ...

global___UpdatePerpetualEventV2 = UpdatePerpetualEventV2

@typing.final
class TradingRewardsEventV1(google.protobuf.message.Message):
    """TradingRewardsEventV1 is communicates all trading rewards for all accounts
    that receive trade rewards in the block.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TRADING_REWARDS_FIELD_NUMBER: builtins.int
    @property
    def trading_rewards(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AddressTradingReward]:
        """The list of all trading rewards in the block."""

    def __init__(
        self,
        *,
        trading_rewards: collections.abc.Iterable[global___AddressTradingReward] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["trading_rewards", b"trading_rewards"]) -> None: ...

global___TradingRewardsEventV1 = TradingRewardsEventV1

@typing.final
class AddressTradingReward(google.protobuf.message.Message):
    """AddressTradingReward contains info on an instance of an address receiving a
    reward
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OWNER_FIELD_NUMBER: builtins.int
    DENOM_AMOUNT_FIELD_NUMBER: builtins.int
    owner: builtins.str
    """The address of the wallet that will receive the trading reward."""
    denom_amount: builtins.bytes
    """The amount of trading rewards earned by the address above in denoms. 1e18
    denoms is equivalent to a single coin.
    """
    def __init__(
        self,
        *,
        owner: builtins.str = ...,
        denom_amount: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["denom_amount", b"denom_amount", "owner", b"owner"]) -> None: ...

global___AddressTradingReward = AddressTradingReward

@typing.final
class OpenInterestUpdateEventV1(google.protobuf.message.Message):
    """OpenInterestUpdateEventV1 is used for open interest update events
    Deprecated.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OPEN_INTEREST_UPDATES_FIELD_NUMBER: builtins.int
    @property
    def open_interest_updates(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OpenInterestUpdate]: ...
    def __init__(
        self,
        *,
        open_interest_updates: collections.abc.Iterable[global___OpenInterestUpdate] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["open_interest_updates", b"open_interest_updates"]) -> None: ...

global___OpenInterestUpdateEventV1 = OpenInterestUpdateEventV1

@typing.final
class OpenInterestUpdate(google.protobuf.message.Message):
    """OpenInterestUpdate contains a single open interest update for a perpetual
    Deprecated.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PERPETUAL_ID_FIELD_NUMBER: builtins.int
    OPEN_INTEREST_FIELD_NUMBER: builtins.int
    perpetual_id: builtins.int
    open_interest: builtins.bytes
    """The new open interest value for the perpetual market."""
    def __init__(
        self,
        *,
        perpetual_id: builtins.int = ...,
        open_interest: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["open_interest", b"open_interest", "perpetual_id", b"perpetual_id"]) -> None: ...

global___OpenInterestUpdate = OpenInterestUpdate

@typing.final
class LiquidityTierUpsertEventV2(google.protobuf.message.Message):
    """LiquidationEventV2 message contains all the information needed to update
    the liquidity tiers. It contains all the fields from V1 along with the
    open interest caps.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    INITIAL_MARGIN_PPM_FIELD_NUMBER: builtins.int
    MAINTENANCE_FRACTION_PPM_FIELD_NUMBER: builtins.int
    BASE_POSITION_NOTIONAL_FIELD_NUMBER: builtins.int
    OPEN_INTEREST_LOWER_CAP_FIELD_NUMBER: builtins.int
    OPEN_INTEREST_UPPER_CAP_FIELD_NUMBER: builtins.int
    id: builtins.int
    """Unique id."""
    name: builtins.str
    """The name of the tier purely for mnemonic purposes, e.g. "Gold"."""
    initial_margin_ppm: builtins.int
    """The margin fraction needed to open a position.
    In parts-per-million.
    """
    maintenance_fraction_ppm: builtins.int
    """The fraction of the initial-margin that the maintenance-margin is,
    e.g. 50%. In parts-per-million.
    """
    base_position_notional: builtins.int
    """The maximum position size at which the margin requirements are
    not increased over the default values. Above this position size,
    the margin requirements increase at a rate of sqrt(size).

    Deprecated since v3.x.
    """
    open_interest_lower_cap: builtins.int
    """Lower cap of open interest in quote quantums. optional"""
    open_interest_upper_cap: builtins.int
    """Upper cap of open interest in quote quantums."""
    def __init__(
        self,
        *,
        id: builtins.int = ...,
        name: builtins.str = ...,
        initial_margin_ppm: builtins.int = ...,
        maintenance_fraction_ppm: builtins.int = ...,
        base_position_notional: builtins.int = ...,
        open_interest_lower_cap: builtins.int = ...,
        open_interest_upper_cap: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["base_position_notional", b"base_position_notional", "id", b"id", "initial_margin_ppm", b"initial_margin_ppm", "maintenance_fraction_ppm", b"maintenance_fraction_ppm", "name", b"name", "open_interest_lower_cap", b"open_interest_lower_cap", "open_interest_upper_cap", b"open_interest_upper_cap"]) -> None: ...

global___LiquidityTierUpsertEventV2 = LiquidityTierUpsertEventV2

@typing.final
class RegisterAffiliateEventV1(google.protobuf.message.Message):
    """Event emitted when a referee is registered with an affiliate."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    REFEREE_FIELD_NUMBER: builtins.int
    AFFILIATE_FIELD_NUMBER: builtins.int
    referee: builtins.str
    """Address of the referee being registered."""
    affiliate: builtins.str
    """Address of the affiliate associated with the referee."""
    def __init__(
        self,
        *,
        referee: builtins.str = ...,
        affiliate: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["affiliate", b"affiliate", "referee", b"referee"]) -> None: ...

global___RegisterAffiliateEventV1 = RegisterAffiliateEventV1

@typing.final
class UpsertVaultEventV1(google.protobuf.message.Message):
    """Event emitted when a vault is created / updated."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ADDRESS_FIELD_NUMBER: builtins.int
    CLOB_PAIR_ID_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    address: builtins.str
    """Address of the vault."""
    clob_pair_id: builtins.int
    """Clob pair Id associated with the vault."""
    status: dydxprotocol.indexer.protocol.v1.vault_pb2.VaultStatus.ValueType
    """Status of the vault."""
    def __init__(
        self,
        *,
        address: builtins.str = ...,
        clob_pair_id: builtins.int = ...,
        status: dydxprotocol.indexer.protocol.v1.vault_pb2.VaultStatus.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["address", b"address", "clob_pair_id", b"clob_pair_id", "status", b"status"]) -> None: ...

global___UpsertVaultEventV1 = UpsertVaultEventV1
