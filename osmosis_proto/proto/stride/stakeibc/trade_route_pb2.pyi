"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import google.protobuf.descriptor
import google.protobuf.message
import stride.stakeibc.ica_account_pb2
import typing

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class TradeConfig(google.protobuf.message.Message):
    """Deprecated, this configuration is no longer needed since swaps
    are executed off-chain via authz

    Stores pool information needed to execute the swap along a trade route
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    POOL_ID_FIELD_NUMBER: builtins.int
    SWAP_PRICE_FIELD_NUMBER: builtins.int
    PRICE_UPDATE_TIMESTAMP_FIELD_NUMBER: builtins.int
    MAX_ALLOWED_SWAP_LOSS_RATE_FIELD_NUMBER: builtins.int
    MIN_SWAP_AMOUNT_FIELD_NUMBER: builtins.int
    MAX_SWAP_AMOUNT_FIELD_NUMBER: builtins.int
    pool_id: builtins.int
    """Currently Osmosis is the only trade chain so this is an osmosis pool id"""
    swap_price: builtins.str
    """Spot price in the pool to convert the reward denom to the host denom
    output_tokens = swap_price * input tokens
    This value may be slightly stale as it is updated by an ICQ
    """
    price_update_timestamp: builtins.int
    """unix time in seconds that the price was last updated"""
    max_allowed_swap_loss_rate: builtins.str
    """Threshold defining the percentage of tokens that could be lost in the trade
    This captures both the loss from slippage and from a stale price on stride
    0.05 means the output from the trade can be no less than a 5% deviation
    from the current value
    """
    min_swap_amount: builtins.str
    """min and max set boundaries of reward denom on trade chain we will swap
    min also decides when reward token transfers are worth it (transfer fees)
    """
    max_swap_amount: builtins.str
    def __init__(
        self,
        *,
        pool_id: builtins.int = ...,
        swap_price: builtins.str = ...,
        price_update_timestamp: builtins.int = ...,
        max_allowed_swap_loss_rate: builtins.str = ...,
        min_swap_amount: builtins.str = ...,
        max_swap_amount: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["max_allowed_swap_loss_rate", b"max_allowed_swap_loss_rate", "max_swap_amount", b"max_swap_amount", "min_swap_amount", b"min_swap_amount", "pool_id", b"pool_id", "price_update_timestamp", b"price_update_timestamp", "swap_price", b"swap_price"]) -> None: ...

global___TradeConfig = TradeConfig

@typing.final
class TradeRoute(google.protobuf.message.Message):
    """TradeRoute represents a round trip including info on transfer and how to do
    the swap. It makes the assumption that the reward token is always foreign to
    the host so therefore the first two hops are to unwind the ibc denom enroute
    to the trade chain and the last hop is the return so funds start/end in the
    withdrawl ICA on hostZone
    The structure is key'd on reward denom and host denom in their native forms
    (i.e. reward_denom_on_reward_zone and host_denom_on_host_zone)
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    REWARD_DENOM_ON_HOST_ZONE_FIELD_NUMBER: builtins.int
    REWARD_DENOM_ON_REWARD_ZONE_FIELD_NUMBER: builtins.int
    REWARD_DENOM_ON_TRADE_ZONE_FIELD_NUMBER: builtins.int
    HOST_DENOM_ON_TRADE_ZONE_FIELD_NUMBER: builtins.int
    HOST_DENOM_ON_HOST_ZONE_FIELD_NUMBER: builtins.int
    HOST_ACCOUNT_FIELD_NUMBER: builtins.int
    REWARD_ACCOUNT_FIELD_NUMBER: builtins.int
    TRADE_ACCOUNT_FIELD_NUMBER: builtins.int
    HOST_TO_REWARD_CHANNEL_ID_FIELD_NUMBER: builtins.int
    REWARD_TO_TRADE_CHANNEL_ID_FIELD_NUMBER: builtins.int
    TRADE_TO_HOST_CHANNEL_ID_FIELD_NUMBER: builtins.int
    MIN_TRANSFER_AMOUNT_FIELD_NUMBER: builtins.int
    TRADE_CONFIG_FIELD_NUMBER: builtins.int
    reward_denom_on_host_zone: builtins.str
    """ibc denom for the reward on the host zone"""
    reward_denom_on_reward_zone: builtins.str
    """should be the native denom for the reward chain"""
    reward_denom_on_trade_zone: builtins.str
    """ibc denom of the reward on the trade chain, input to the swap"""
    host_denom_on_trade_zone: builtins.str
    """ibc of the host denom on the trade chain, output from the swap"""
    host_denom_on_host_zone: builtins.str
    """should be the same as the native host denom on the host chain"""
    host_to_reward_channel_id: builtins.str
    """Channel responsible for the transfer of reward tokens from the host
    zone to the reward zone. This is the channel ID on the host zone side
    """
    reward_to_trade_channel_id: builtins.str
    """Channel responsible for the transfer of reward tokens from the reward
    zone to the trade zone. This is the channel ID on the reward zone side
    """
    trade_to_host_channel_id: builtins.str
    """Channel responsible for the transfer of host tokens from the trade
    zone, back to the host zone. This is the channel ID on the trade zone side
    """
    min_transfer_amount: builtins.str
    """Minimum amount of reward token that must be accumulated before
    the tokens are transferred to the trade ICA
    """
    @property
    def host_account(self) -> stride.stakeibc.ica_account_pb2.ICAAccount:
        """ICAAccount on the host zone with the reward tokens
        This is the same as the host zone withdrawal ICA account
        """

    @property
    def reward_account(self) -> stride.stakeibc.ica_account_pb2.ICAAccount:
        """ICAAccount on the reward zone that is acts as the intermediate
        receiver of the transfer from host zone to trade zone
        """

    @property
    def trade_account(self) -> stride.stakeibc.ica_account_pb2.ICAAccount:
        """ICAAccount responsible for executing the swap of reward
        tokens for host tokens
        """

    @property
    def trade_config(self) -> global___TradeConfig:
        """Deprecated, the trades are now executed off-chain via authz
        so the trade configuration is no longer needed

        specifies the configuration needed to execute the swap
        such as pool_id, slippage, min trade amount, etc.
        """

    def __init__(
        self,
        *,
        reward_denom_on_host_zone: builtins.str = ...,
        reward_denom_on_reward_zone: builtins.str = ...,
        reward_denom_on_trade_zone: builtins.str = ...,
        host_denom_on_trade_zone: builtins.str = ...,
        host_denom_on_host_zone: builtins.str = ...,
        host_account: stride.stakeibc.ica_account_pb2.ICAAccount | None = ...,
        reward_account: stride.stakeibc.ica_account_pb2.ICAAccount | None = ...,
        trade_account: stride.stakeibc.ica_account_pb2.ICAAccount | None = ...,
        host_to_reward_channel_id: builtins.str = ...,
        reward_to_trade_channel_id: builtins.str = ...,
        trade_to_host_channel_id: builtins.str = ...,
        min_transfer_amount: builtins.str = ...,
        trade_config: global___TradeConfig | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["host_account", b"host_account", "reward_account", b"reward_account", "trade_account", b"trade_account", "trade_config", b"trade_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["host_account", b"host_account", "host_denom_on_host_zone", b"host_denom_on_host_zone", "host_denom_on_trade_zone", b"host_denom_on_trade_zone", "host_to_reward_channel_id", b"host_to_reward_channel_id", "min_transfer_amount", b"min_transfer_amount", "reward_account", b"reward_account", "reward_denom_on_host_zone", b"reward_denom_on_host_zone", "reward_denom_on_reward_zone", b"reward_denom_on_reward_zone", "reward_denom_on_trade_zone", b"reward_denom_on_trade_zone", "reward_to_trade_channel_id", b"reward_to_trade_channel_id", "trade_account", b"trade_account", "trade_config", b"trade_config", "trade_to_host_channel_id", b"trade_to_host_channel_id"]) -> None: ...

global___TradeRoute = TradeRoute
